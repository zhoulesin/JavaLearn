# 并发集合

http://ifeve.com/concurrent-collections-1/

Java提供了你可以在你的并发程序中使用的，而且不会有任何问题或不一致的数据集合。基本上Java提供两种在并发应用程序中使用的集合：

- 阻塞集合:这种集合包括添加和删除数据的操作。如果操作不能立即进行，时因为集合已满或者为空，该程序将被阻塞，直到操作可以进行。
- 非阻塞集合：这种集合包括添加和删除数据的操作。如果操作不能立即进行，这个操作将返回null或抛出异常，但该线程将不会阻塞。

## 使用非阻塞线程安全的列表

列表list是最基本的集合。一个列表有不确定的元素数量，并且你可以添加，读取和删除任意位置上的元素。并发列表允许不同的线程在同一时刻对列表的元素进行添加或删除，而不会产生任何数据不一致的问题。

非阻塞列表提供这些操作：如果操作不能立即完成，它将根据这个操作抛出异常或返回null。Java 7 引进了实现非阻塞并发列表的ConcurrentLinkedDeque类

使用两个任务来实现一个例子

- 大量添加数据到列表
- 在同个列表中，大量删除数据

见ConcurrentLinkedDequeDemo,ConcurrentLinkedDeque类提供更多的方法来获取列表的元素:
- getFirst()和getLast():这些方法将分别返回列表的第一个和最后一个元素。他们不会从列表删除返回的元素，如果列表为空，这些方法将抛出NoSuchElementException
- peek()，peekFirst(),peekLast():这些方法将分别返回列表的第一个和最后一个元素。他们不会从列表中删除返回的元素。如果列表为空，这些方法将返回null
- remove，removeFirst，removeLast：这些方法将分别返回列表的第一个和最后一个元素。他们将从列表中删除返回的元素。如果列表为空，这些方法将抛出NoSuchElementException
- poll,pollFirst,pollLast:这些方法将分别返回列表的第一个和最后一个元素。他们将从列表中删除返回的元素。如果列表为空，这些方法将返回null

## 使用阻塞线程安全的列表

阻塞列表与非阻塞列表的主要区别时，阻塞列表有添加和删除元素的方法，如果由于列表已满或为空而导致这些操作不能立即进行，他们将阻塞调用的线程，直到这些操作可以进行。Java包含实现阻塞列表的LinkedBlockingDeque类.

使用两个任务来实现例子:

- 添加大量数据到列表
- 从同一个列表中删除大量的数据

Client类使用put方法添加字符串到列表中。如果列表已满（使用了固定大小来创建），这个方法阻塞线程的执行，直到列表有可用空间。

Main类使用take方法从列表中获取，如果列表为空，这个方法将阻塞线程的执行，直到列表中有元素。

如果着两个方法再阻塞时被中断，将抛出InterruptedException.

LinkedBlockingDeque同时提供了添加和获取元素的其他方法，不被阻塞，或抛出异常，或返回null

- takeFisrt和takeLast：这些方法分别返回列表的第一个和最后一个元素。他们从列表删除返回的元素。如果列表为空，这些方法将阻塞线程，直到列表有元素
- getFirst和getLast：这些方法分别返回列表的第一个和最后一个元素。他们不会从列表删除返回的元素。如果列表为空，这些方法将会抛出NoSuchElementException
- peek，peekFirst，peekLast：这些方法分别返回列表的第一个和最后一个元素。他们不会从列表删除返回的元素。如果列表为空，这些方法将返回null
- poll，pollFirst，pollLast：这些方法分别返回列表的第一个和最后一个元素。他们从列表中删除返回的元素。如果列表为空，这些方法将返回null
- add，addFirst，addLast：这些方法分别再第一个位置和最后一个位置添加元素，如果列表已满，这些方法将抛出IllegalStateException